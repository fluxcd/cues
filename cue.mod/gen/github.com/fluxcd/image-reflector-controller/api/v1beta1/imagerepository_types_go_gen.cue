// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/fluxcd/image-reflector-controller/api/v1beta1

package v1beta1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"github.com/fluxcd/pkg/apis/meta"
	"github.com/fluxcd/pkg/apis/acl"
)

#ImageRepositoryKind: "ImageRepository"

#ImageRepositoryFinalizer: "finalizers.fluxcd.io"

// ImageRepositorySpec defines the parameters for scanning an image
// repository, e.g., `fluxcd/flux`.
#ImageRepositorySpec: {
	// Image is the name of the image repository
	// +required
	image?: string @go(Image)

	// Interval is the length of time to wait between
	// scans of the image repository.
	// +kubebuilder:validation:Type=string
	// +kubebuilder:validation:Pattern="^([0-9]+(\\.[0-9]+)?(ms|s|m|h))+$"
	// +required
	interval?: metav1.#Duration @go(Interval)

	// Timeout for image scanning.
	// Defaults to 'Interval' duration.
	// +kubebuilder:validation:Type=string
	// +kubebuilder:validation:Pattern="^([0-9]+(\\.[0-9]+)?(ms|s|m))+$"
	// +optional
	timeout?: null | metav1.#Duration @go(Timeout,*metav1.Duration)

	// SecretRef can be given the name of a secret containing
	// credentials to use for the image registry. The secret should be
	// created with `kubectl create secret docker-registry`, or the
	// equivalent.
	// +optional
	secretRef?: null | meta.#LocalObjectReference @go(SecretRef,*meta.LocalObjectReference)

	// ServiceAccountName is the name of the Kubernetes ServiceAccount used to authenticate
	// the image pull if the service account has attached pull secrets.
	// +kubebuilder:validation:MaxLength=253
	// +optional
	serviceAccountName?: string @go(ServiceAccountName)

	// CertSecretRef can be given the name of a secret containing
	// either or both of
	//
	//  - a PEM-encoded client certificate (`certFile`) and private
	//  key (`keyFile`);
	//  - a PEM-encoded CA certificate (`caFile`)
	//
	//  and whichever are supplied, will be used for connecting to the
	//  registry. The client cert and key are useful if you are
	//  authenticating with a certificate; the CA cert is useful if
	//  you are using a self-signed server certificate.
	// +optional
	certSecretRef?: null | meta.#LocalObjectReference @go(CertSecretRef,*meta.LocalObjectReference)

	// This flag tells the controller to suspend subsequent image scans.
	// It does not apply to already started scans. Defaults to false.
	// +optional
	suspend?: bool @go(Suspend)

	// AccessFrom defines an ACL for allowing cross-namespace references
	// to the ImageRepository object based on the caller's namespace labels.
	// +optional
	accessFrom?: null | acl.#AccessFrom @go(AccessFrom,*acl.AccessFrom)

	// ExclusionList is a list of regex strings used to exclude certain tags
	// from being stored in the database.
	// +optional
	exclusionList?: [...string] @go(ExclusionList,[]string)
}

#ScanResult: {
	tagCount:  int          @go(TagCount)
	scanTime?: metav1.#Time @go(ScanTime)
}

// ImageRepositoryStatus defines the observed state of ImageRepository
#ImageRepositoryStatus: {
	// +optional
	conditions?: [...metav1.#Condition] @go(Conditions,[]metav1.Condition)

	// ObservedGeneration is the last reconciled generation.
	// +optional
	observedGeneration?: int64 @go(ObservedGeneration)

	// CanonicalName is the name of the image repository with all the
	// implied bits made explicit; e.g., `docker.io/library/alpine`
	// rather than `alpine`.
	// +optional
	canonicalImageName?: string @go(CanonicalImageName)

	// LastScanResult contains the number of fetched tags.
	// +optional
	lastScanResult?: null | #ScanResult @go(LastScanResult,*ScanResult)

	meta.#ReconcileRequestStatus
}

// ImageRepository is the Schema for the imagerepositories API
#ImageRepository: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta   @go(ObjectMeta)
	spec?:     #ImageRepositorySpec @go(Spec)

	// +kubebuilder:default={"observedGeneration":-1}
	status?: #ImageRepositoryStatus @go(Status)
}

// ImageRepositoryList contains a list of ImageRepository
#ImageRepositoryList: {
	metav1.#TypeMeta
	metadata?: metav1.#ListMeta @go(ListMeta)
	items: [...#ImageRepository] @go(Items,[]ImageRepository)
}
